# TODO: make a module with this?
- name: check if port 80 is used
  become: true
  shell: netstat -tuln | grep ':80 '
  register: port_80
  failed_when: False # never fail

- name: check ufw status
  become: yes
  command: ufw status verbose
  ignore_errors: yes
  register: ufw_status

- name: determine if firewall is running and blocking port 80
  set_fact:
    firewall_installed: '{{ ufw_status is succeeded }}'
    firewall_running: '{{ ufw_status is succeeded and not ufw_status.stdout is match("Status: inactive") }}'
    firewall_blocking_80: '{{ ufw_status is succeeded and not ufw_status.stdout is search("80/tcp.*ALLOW IN") }}'

#
# If nothing binding to port 80, use certbot standalone
#

- name: open firewall for certbot
  become: true
  ufw: rule=allow port=80 proto=tcp
  notify: restart ufw
  when: firewall_blocking_80 # port was not open yet

- name: start the certbot container standalone
  docker_container:
    name: certbot
    image: certbot/certbot
    command: '{{ certbot_standalone_cmd }}'
    volumes:
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/log/letsencrypt:/var/log/letsencrypt
    published_ports:
      - 80:80
    # auto_remove: true # on ansible 2.4
    detach: false
  when: port_80.rc == 1 # port not used


#
# If something already using port 80, try webroot
#

- name: start the certbot container webroot
  docker_container:
    name: certbot
    image: certbot/certbot
    command: '{{ certbot_webroot_cmd }}'
    volumes:
      - /var/www:/var/www # webroot
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/log/letsencrypt:/var/log/letsencrypt
    # auto_remove: true # on ansible 2.4
    detach: false
  when: port_80.rc == 0


- name: close firewall after certbot standalone
  become: true
  ufw: rule=allow port=80 proto=tcp delete=true
  notify: restart ufw
  when: firewall_blocking_80 # port was not open before


- include: cron.yml
  tags: [cron]

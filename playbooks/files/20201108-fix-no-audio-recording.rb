# encoding: UTF-8

require 'nokogiri'
require 'date'
require 'json'

FFPROBE = ['ffprobe', '-v', 'warning', '-print_format', 'json', '-show_format', '-show_streams']

data = {}

def audio_info(filename)
  IO.popen([*FFPROBE, filename]) do |probe|
    info = nil
    begin
      info = JSON.parse(probe.read, :symbolize_names => true)
    rescue StandardError => e
      return {}
    end
    return {} if !info
    return {} if !info[:streams]
    return {} if !info[:format]

    info[:audio] = info[:streams].find do |stream|
      stream[:codec_type] == 'audio'
    end
    return {} if !info[:audio]

    info[:sample_rate] = info[:audio][:sample_rate].to_i

    if info[:format][:format_name] == 'wav'
      # wav files generated by freeswitch can have incorrect length
      # field if longer than 4GB, so recalculate based on filesize (ouch!)
      audio_offset = get_wave_data_offset(filename)
      audio_size = info[:format][:size].to_r - audio_offset
      info[:duration] = (audio_size * 8 / info[:audio][:bit_rate].to_i * 1000).to_i
    else
      info[:duration] = (info[:format][:duration].to_r * 1000).to_i
    end

    return info
  end
  {}
end

def get_wave_data_offset(filename)
  File.open(filename, 'rb') do |file|
    riff = file.read(4)
    wavesize = file.read(4).unpack('V')[0].to_i
    wave = file.read(4)
    if riff != 'RIFF' or wavesize.nil? or wave != 'WAVE'
      return 0
    end
    while true
      # Read chunks until we find one named 'data'
      chunkname = file.read(4)
      chunksize = file.read(4).unpack('V')[0].to_i
      if chunkname.nil? or chunksize.nil?
        return 0
      end
      if chunkname == 'data'
        # This is a data chunk; we've found the start of the real audio data
        return file.tell
      end
      file.seek(chunksize, IO::SEEK_CUR)
    end
    return 0
  end
end

def format_duration(duration)
  h = ( duration / 3600000 ).to_i
  m = ( ( duration % 3600000 ) / 60000 ).to_i
  s = ( ( ( duration % 3600000 ) % 60000 ) / 1000 ).to_i
  ms = ( ( ( duration % 3600000 ) % 60000 ) % 1000 ).to_i
  "%02d:%02d:%02d.%03d" % [h, m, s, ms]
end

def record_id_to_timestamp(r)
    r.split("-")[1].to_i
end

def format_timestamp(timestamp)
  format_date_time(timestamp_to_date(timestamp))
end

def timestamp_to_date(ms)
  DateTime.strptime(ms.to_s,'%Q')
end

def format_date_time(d)
  # timezone = TZInfo::Timezone.get("America/Sao_Paulo")
  # local_date = timezone.utc_to_local(d)
  # local_date.strftime("%d/%m/%Y %H:%M:%S")
  d.strftime("%d/%m/%Y %H:%M:%S")
end

def format_date_from_record_id(r)
  format_date_time(timestamp_to_date(record_id_to_timestamp(r)))
end

to_rebuild = []

Dir.glob("/var/bigbluebutton/recording/raw/*/events.xml").each do |events_xml|
  record_id = File.basename(File.dirname(events_xml))

  doc = Nokogiri::XML(File.open(events_xml)) { |x| x.noblanks }
  next if doc.xpath("/recording/event").length == 0
  next if doc.xpath("/recording/event[@module='PARTICIPANT' and @eventname='RecordStatusEvent']").length == 0

  mark_to_rebuild = false
  last_timestamp = doc.at_xpath('/recording/event[position() = last()]/@timestamp').text.to_i
  doc.xpath("/recording/event[@module='VOICE' and @eventname='StartRecordingEvent']").each do |event|
    filename = event.at_xpath("filename").text
    event_start = event.at_xpath("recordingTimestamp").text.to_i
    file_path = "#{File.dirname(events_xml)}/audio/#{File.basename(filename)}"
    next if ! File.exists? file_path
    info = audio_info(file_path)

    if info[:duration].nil?
      node = doc.xpath("/recording/event[@module='VOICE' and @eventname='StopRecordingEvent' and ./filename='#{filename}']").first
      event_stop = node.nil? ? last_timestamp : node.at_xpath("./recordingTimestamp").text.to_i
      event_duration = event_stop - event_start

      # do not consider events shorter than 10s
      next if event_duration < 10000

      mark_to_rebuild = true
      break
    end
  end
  to_rebuild << record_id if mark_to_rebuild
end

to_rebuild.each do |record_id|
  puts `bbb-record --rebuild #{record_id}`
end
